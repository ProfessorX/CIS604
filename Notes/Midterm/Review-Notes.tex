
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
\documentclass[twocolumn]{article}

% Packages
% \usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[margin=10mm]{geometry}
\usepackage{xcolor}
\usepackage{graphicx}



% Housekeeping
\pagestyle{empty}


\begin{document}
\section{Artificial Intelligence}
\label{sec:artif-intell}

%%% Ideas:
% There should be more than these note points. Add some when you do
% the second time reviewing.
\begin{itemize}
% \item Life is fucking awesome in the United Arab Emirates!
% \item Life is a bitch. Fuck it or leave it, choose one.
\item An \textbf{agent} is an entity that can perceive and act. This
  course is about designing rational agents. 
\item Rational behavior: doing the right thing. 
\item Environment Types: Fully observable; Deterministic; Episodic;
  Static, Discrete; Single-agent. The counter part: partially
  observable; stochastic; sequential; dynamic; continuous;
  multi-agent. 
\item An agent is anything that can be viewed as perceiving its
  environment through sensors and acting upon that environment through
  actuators.
\end{itemize}


\section{Problem Solving}
\label{sec:problem-solving}

\begin{itemize}
% \item Life is fucking awesome in the United Arab Emirates!
\item A search problem consists of 
  \begin{itemize}
  \item a state space
  \item a successor function (namely \textbf{update function} in data
    mining algorithm series, more namely \textbf{recursion} in
    bullshit technology.)
  \item a start state (\textbf{initial value}), goal test
    (\textbf{terminating value}) and path cost function (\textbf{we
      say weights in Graph Theory})
  \item Does any one of the above reminds you of \textbf{recursion}?
  \end{itemize}
\item Problems are often modelled as a state space, a set of states
  that a problem can be in. The set of states forms a graph where two
  states are \textbf{connected} if there is an operation that can be
  performed to transform the first state into the second.
\item A solution is a sequence of actions (a plan) which transforms
  the start state to a goal state.
\item \textbf{State space graph}: A mathematical representation of a
  search problem.
\item \textbf{Search Trees} 
  \begin{itemize}
  \item This is a ``what-if'' tree of plans and outcomes
  \item For most problems, we can never actually build the whole tree
  \end{itemize}
\item \textbf{General Tree Search} Frontier; Expansion; Exploration
  Strategy.
\item \textbf{States vs. Nodes} Nodes in state space graphs are
  problem states; Nodes in search trees are plans. {\color{red}The same problem
  state may be achieved by multiple search tree nodes.}
\item \textbf{Graph Search} Graph Search still  produces a search
  tree; Graph search is almost always better than tree search.
\item DFS graph search needs to store ``explored set'', which is
  $O(b^{m})$. However, \textbf{DFS is optimal} when the search tree is finite,
  all action costs are identical and all solutions have the same
  length. However limitating this may sound, there is an important
  class of problems that satisfies these conditions: the CSPs
  (constraint satisfaction problems). Maybe all the examples you
  thought about fall in this (rather common) category. 
\item The breadth first search and iterative deepening are
  conceptually and computationally the same. The only difference is
  the ``space'' (we call them \textbf{memory}) would be partially
  saved by iterative deepening search.
\item \textbf{Heuristics} estimate of how close a node is to a goal;
  Designed for a particular search problem. 
% \item Life is fucking awesome in the United Arab Emirates.
\item \textbf{A star search} Uniform-cost orders by \textbf{path cost}, or
  backward cost  $g(n)$; Best-first orders by \textbf{distance} to goal, or
  forward cost $h(n)$. A* Search orders by the sum:
  $f(n)=g(n)+h(n)$. The distance is an estimated one.
\item When A* terminates its search, it has, by definition, found a
  path whose actual cost is lower than the estimated cost of any path
  through any node on the frontier. But since those estimates are
  optimistic, A* can safely ignore those nodes.
\item In general, most natural admissible heuristics tend to be
  consistent, especially if from relaxed problems. 
\item 
\end{itemize}

\end{document}
